use std::uninitialized_copy



#ifndef VECTOR_HPP
#define VECTOR_HPP

#include <memory>
#include <cassert>
#include "utility.hpp"
#include "iterator_traits.hpp"

namespace ft
{
//________________________________________________________________________________________________________
//________________________________________________________________________________________________________
	// template <class _Iter>
	// class base_iter
	template <class T, class D, class Pt, class Rt>
	class base_iter : public iterator<std::random_access_iterator_tag, T, D, Pt, Rt>
	{
	public:
		// typedef _Iter														iterator_type;
		// typedef typename iterator_traits<iterator_type>::iterator_category	iterator_category;
		// typedef typename iterator_traits<iterator_type>::value_type			value_type;
		// typedef typename iterator_traits<iterator_type>::difference_type	difference_type;
		// typedef typename iterator_traits<iterator_type>::pointer			pointer;
		// typedef typename iterator_traits<iterator_type>::reference			reference;
		typedef T																					iterator_type;
		typedef typename iterator<std::random_access_iterator_tag, T, D, Pt, Rt>::iterator_category	iterator_category;
		typedef typename iterator<std::random_access_iterator_tag, T, D, Pt, Rt>::value_type		value_type;
		typedef typename iterator<std::random_access_iterator_tag, T, D, Pt, Rt>::difference_type	difference_type;
		typedef typename iterator<std::random_access_iterator_tag, T, D, Pt, Rt>::pointer			pointer;
		typedef typename iterator<std::random_access_iterator_tag, T, D, Pt, Rt>::reference			reference;

		typedef base_iter<T, D, Pt, Rt> my_iter;
	private:
		pointer __i;

	public:
		base_iter(){}
		base_iter(pointer __x) : __i(__x) {}
		// template <class _Up> 
		// base_iter(const base_iter<_Up>& __u, typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) 
		//         : __i(__u.base()) {}
		// ~base_iter() {}

		reference operator*() const { return *__i; }
		pointer  operator->() const { return __i; }
		my_iter& operator++(){ ++__i; return *this; }
		my_iter  operator++(int) { base_iter __tmp = *this; ++(*this); return __tmp; }
		my_iter& operator--() { --__i; return *this; }
		my_iter  operator--(int) { base_iter __tmp = *this; --(*this); return __tmp; }
		my_iter  operator+ (difference_type __n) const { base_iter __w(*this); __w += __n; return __w; }
		my_iter& operator+=(difference_type __n) { __i += __n; return *this; }
		my_iter  operator- (difference_type __n) const { return *this + (-__n); }
		my_iter& operator-=(difference_type __n) {*this += -__n; return *this;}
		reference operator[](difference_type __n) const { return __i[__n]; }
		pointer base() {return __i;}

	// template <class _Iter1, class _Iter2>
	// inline bool operator==(const base_iter<_Iter1>& __x, const base_iter<_Iter2>& __y) { return __x.base() == __y.base(); }
	
	// template <class _Iter1, class _Iter2>
	// inline bool operator<(const base_iter<_Iter1>& __x, const base_iter<_Iter2>& __y) { return __x.base() < __y.base(); }

	// template <class _Iter1, class _Iter2>
	// inline bool operator!=(const base_iter<_Iter1>& __x, const base_iter<_Iter2>& __y) { return !(__x == __y); }

	// template <class _Iter1, class _Iter2>
	// inline bool operator>(const base_iter<_Iter1>& __x, const base_iter<_Iter2>& __y) { return __y < __x; }

	// template <class _Iter1, class _Iter2>
	// inline bool operator>=(const base_iter<_Iter1>& __x, const base_iter<_Iter2>& __y) { return !(__x < __y); }

	// template <class _Iter1, class _Iter2>
	// inline bool operator<=(const base_iter<_Iter1>& __x, const base_iter<_Iter2>& __y) { return !(__y < __x); }

	// template <class _Iter1>
	// inline bool operator!=(const base_iter<_Iter1>& __x, const base_iter<_Iter1>& __y) { return !(__x == __y); }

	// template <class _Iter1>
	// inline bool operator>(const base_iter<_Iter1>& __x, const base_iter<_Iter1>& __y) { return __y < __x; }

	// template <class _Iter1>
	// inline bool operator>=(const base_iter<_Iter1>& __x, const base_iter<_Iter1>& __y) { return !(__x < __y); }

	// template <class _Iter1>
	// inline bool operator<=(const base_iter<_Iter1>& __x, const base_iter<_Iter1>& __y) { return !(__y < __x); }

	// template <class _Iter1, class _Iter2>
	// inline typename base_iter<_Iter1>::difference_type operator-(const base_iter<_Iter1>& __x, const base_iter<_Iter2>& __y) { return __x.base() - __y.base(); }

	// template <class _Iter>
	// inline base_iter<_Iter> operator+(typename base_iter<_Iter>::difference_type __n, base_iter<_Iter> __x) { __x += __n; return __x; }
	};

	template <class T1, class D1, class Pt1, class Rt1, class T2, class D2, class Pt2, class Rt2>
	inline bool operator==(base_iter<T1, D1, Pt1, Rt1>& __x, base_iter<T2, D2, Pt2, Rt2>& __y) { return __x.base() == __y.base(); }

	template <class T1, class D1, class Pt1, class Rt1, class T2, class D2, class Pt2, class Rt2>
	inline bool operator!=(base_iter<T1, D1, Pt1, Rt1>& __x, base_iter<T2, D2, Pt2, Rt2>& __y) { return !(__x == __y); }
//________________________________________________________________________________________________________
//_____________________________________________VECTOR_____________________________________________________
//________________________________________________________________________________________________________
    template<class T, class Allocator = std::allocator<T> >
    class vector
    {
    public:
		typedef T											value_type;//mlikt
		typedef Allocator									allocator_type;//mlikt
		typedef typename allocator_type::reference			reference;
		typedef typename allocator_type::const_reference	const_reference;
		typedef typename allocator_type::size_type			size_type;
		typedef typename allocator_type::difference_type	difference_type;
		typedef typename allocator_type::pointer			pointer;
		typedef typename allocator_type::const_pointer		const_pointer;
		typedef base_iter<value_type, difference_type, pointer, reference>	iterator;
		typedef base_iter<value_type, difference_type, const_pointer, const_reference>	const_iterator;
		// typedef base_iter<value_type>				   			iterator;
		// typedef base_iter<const value_type>					const_iterator;
		typedef ft::reverse_iterator<iterator>				reverse_iterator;
		typedef ft::reverse_iterator<const_iterator>		const_reverse_iterator;

    protected:
		allocator_type		_alloc;
		pointer				_begin;
		pointer				_end;
		pointer				_end_cap;

//construct/copy/destroy:
	public:
		explicit vector(const Allocator& _a = Allocator()) : _begin(nullptr), _end(nullptr), _end_cap(nullptr), _alloc(_a) {}

		explicit vector(size_type n, const T& value = T(), const Allocator& _a= Allocator()) : _alloc(_a){
			if (n > _alloc.max_size())
				throw std::length_error("bad size vector");
			else if (n > 0)
			{
				_begin = _end = _alloc.allocate(n);
				while (n--)
					_alloc.construct(_end++, value);
				_end_cap = _end;
			}
		}

		template <class InputIter>
		vector(InputIter __first, InputIter __last, const Allocator& _a = Allocator(), 
		       typename ft::enable_if<!ft::is_integral<InputIter>::value, void>::type* = 0) //?????
			   : _begin(nullptr), _end(nullptr), _end_cap(nullptr), _alloc(_a)
		{
			size_type n = ft::distance(__first, __last);
			if (n > max_size())
				throw std::length_error("bad size vector");
			_begin = _alloc.allocate(n);
			_end = _end_cap = _begin + n;
			pointer it = _begin;
			while (it != _end)
				_alloc.construct(it++, *__first++);
		}

		vector(const vector<T,Allocator>& x) : _alloc(x.get_allocator()){
			size_type n = x.size();
			pointer it = x._begin;
			if (n > 0)
			{
				_begin = _end = _alloc.allocate(n);
				while (it != x._end)
					_alloc.construct(_end++, *it++);
				_end_cap = _end;
			}
		}

		~vector(){
				if (_begin != nullptr)
				{
						clear();
						_alloc.deallocate(_begin, capacity());
						_begin = _end = _end_cap = nullptr;
				}
		}

		vector<T,Allocator>& operator=(const vector<T,Allocator>& x){
			if (this != &x)
				assign(x._begin, x._end);
			return *this;
		}

		template <class InputIter>
		typename ft::enable_if<!ft::is_integral<InputIter>::value, void>::type 
		assign(InputIter first, InputIter last){
			clear();
			size_type n = static_cast<size_type>(ft::distance(first, last));
			if (capacity() < n)
				reserve(n);
			while (first != last)
				_alloc.construct(_end++, *first++);
		}

		void assign(size_type n, const T& x){
			clear();
			if (capacity() < n)
				reserve(n);
			while (n--)
				_alloc.construct(_end++, x);
		}

		allocator_type get_allocator() const { return _alloc; }
		
//iterators
		iterator begin() { return (iterator(_begin)); }
		const_iterator begin() const { return (const_iterator(_begin)); }
		iterator end() { return (iterator(_end)); }
		const_iterator end() const { return (const_iterator(_end)); }

		reverse_iterator rbegin() { return (reverse_iterator(end())); }
		const_reverse_iterator rbegin() const { return (const_reverse_iterator(end())); }
		reverse_iterator rend() { return (reverse_iterator(begin())); }
		const_reverse_iterator rend() const { return (const_reverse_iterator(begin())); }

//capacity
		size_type size() const { return static_cast<size_type>(_end - _begin); }
		size_type max_size() const {return _alloc.max_size(); }
		size_type capacity() const { return (_end_cap - _begin); }
		bool empty() const { return _begin == _end; }
		void reserve(size_type n)
		{
			if (n > max_size())
				throw std::length_error("bad size vector");
			else if (n > capacity())
			{
				pointer new_begin, new_end;		
				new_begin = new_end = _alloc.allocate(n);
				pointer it = _begin;
				try
				{
					while (it != _end)
						_alloc.construct(new_end++, *it++);
				}
				catch(...)
				{
					_alloc.deallocate(new_begin, n);
					throw ;
				}
				it = _begin;
				while (it != _end)
					_alloc.destroy(it++);
				_alloc.deallocate(_begin, capacity());
				_begin = new_begin;
				_end = new_end;
				_end_cap = _begin + n;
			}
		}

		void resize(size_type n, T c = T()){
			size_type sz = size();
			if (sz < n)
			{
				if (capacity() < n)
					reserve(n);
				pointer new_end = _begin + n;
				while (_end != new_end)
					_alloc.construct(_end++, c);
			}
			else
			{
				pointer new_end = _begin + n;
				while (_end != new_end)
					_alloc.destruct(--_end);
			}
		}

//element access
		reference       operator[](size_type n){
			assert(n < size() && "vector[] index out of bounds");
			return this->_begin[n]; // *(_begin + n); 	
		}
		const_reference operator[](size_type n) const{
			assert(n < size() && "vector[] index out of bounds");
			return this->_begin[n]; // *(_begin + n); 			
		}
		reference       at(size_type n){
			if (n >= size())
				throw std::out_of_range("vector");
			return this->_begin[n]; // *(_begin + n); 	
		}
		const_reference at(size_type n) const{
			if (n >= size())
				throw std::out_of_range("vector");
			return this->_begin[n]; // *(_begin + n); 	
		}
		reference       front() { return *_begin; }
		const_reference front() const { return *_begin; }
		reference       back() { return *(_end - 1); }
		const_reference back() const { return *(_end - 1); }

//Modifiers
		void push_back(const value_type& x){
			size_type csz = capacity();
			if (csz == 0)
				reserve(1);
			else if (_end == _end_cap)
				reserve(2 * csz);
			_alloc.construct(_end++, x);
		}

		void pop_back(){
			assert(!empty() && "vector::pop_back called for empty vector");
			_alloc.destruct(--_end);
		}

		// iterator insert(const_iterator position, const value_type& x){
		iterator insert(iterator position, const value_type& x){
			size_type csz = capacity();
			difference_type diff_pos = position - begin();
			if (_end == _end_cap)
			{
				csz = (csz == 0) ? 1 : 2 * csz;
				if (csz > max_size())
					throw std::length_error("bad size vector");
				pointer new_begin, new_end;		
				new_begin = new_end = _alloc.allocate(csz);
				pointer it = _begin;
				try
				{
					while (it != position)
						_alloc.construct(new_end++, *it++);
					_alloc.construct(new_end++, x);
					while (it != _end)
						_alloc.construct(new_end++, *it++);
				}
				catch(...)
				{
					_alloc.deallocate(new_begin, csz);
					throw ;
				}
				it = _begin;
				while (it != _end)
					_alloc.destroy(it++);
				_alloc.deallocate(_begin, capacity());
				_begin = new_begin;
				_end = new_end;
				_end_cap = _begin + csz;
				position = _begin + diff_pos;
			}
			else
			{
				pointer it = _end - 1;
				_end++;
				while (it != position)
					_alloc.construct(it + 1, *it--);
				_alloc.construct(position, x);
			}
			return iterator(position);
		}

/*
		iterator insert(const_iterator position, size_type n, const value_type& x){
			size_type new_csz = size() + n;
			size_type old_csz = capacity();
			if (old_csz < new_csz)
			{
				old_csz *= 2;
				new_csz = (new_csz > old_csz) ? new_csz : old_csz;
				difference_type diff_pos = position - begin();
				if (new_csz > max_size())
					throw std::length_error("bad size vector");
				pointer new_begin, new_end;		
				new_begin = new_end = _alloc.allocate(new_csz);
				pointer it = _begin;
				try
				{
					while (it != position)
						_alloc.construct(new_end++, *it++);
					it += n;
					while (it != _end)
						_alloc.construct(new_end++, *it++);
				}
				catch(...)
				{
					_base::_alloc.deallocate(new_begin, n);
					throw ;
				}
				it = _begin;
				while (it != _end)
					_alloc.destroy(it++);
				_alloc.deallocate(_begin, capacity());
				_begin = new_begin;
				_end = new_end;
				_end_cap = _begin + new_csz;
				position = _begin + diff_pos;
			}
			else
			{
				pointer it = _end - 1;
				_end += n;
				while (it != position)
					_alloc.construct(it + n, *it--);
			}
			for (size_type i = 0; i < n; i++)
				_alloc.construct(position + i, x);
			return iterator(position);
		}

		template <class InputIter>
		typename ft::enable_if<!ft::is_integral<InputIter>::value, void>::type
		insert(const_iterator position, InputIter first, InputIter last)
		{
			difference_type __off = position - begin();
			pointer __p = _begin + __off;
			// ...
			return begin() + __off;

			//
			size_type n = static_cast<size_type>(ft::distance(first, last));
			size_type new_csz = size() + n;
			if (capacity() < new_csz)
			{
				difference_type diff_pos = position - begin();
				if (new_csz > max_size())
					throw std::length_error("bad size vector");
				pointer new_begin, new_end;		
				new_begin = new_end = _alloc.allocate(n);
				pointer it = _begin;
				try
				{
					while (it != position)
						_alloc.construct(new_end++, *it++);
					it += n;
					while (it != _end)
						_alloc.construct(new_end++, *it++);
				}
				catch(...)
				{
					_base::_alloc.deallocate(new_begin, n);
					throw ;
				}
				it = _begin;
				while (it != _end)
					_alloc.destroy(it++);
				_alloc.deallocate(_begin, capacity());
				_begin = new_begin;
				_end = new_end;
				_end_cap = _begin + new_csz;
				position = _begin + diff_pos;
			}
			else
			{
				pointer it = _end - 1;
				_end += n;
				while (it != position)
					_alloc.construct(it + n, *it--);
			}
			for (size_type i = 0; i < n; i++)
				_alloc.construct(position + i, x);
			return iterator(position);
		}
	// rewrite
		iterator erase(iterator position){
			// difference_type __ps = __position - cbegin();
			// pointer __p = _begin + __ps;
			// this->__destruct_at_end(_VSTD::move(__p + 1, this->__end_, __p));
			// this->__invalidate_iterators_past(__p-1);
			// return iterator(__p);
		}
		iterator erase(iterator first, iterator last){
			// assert( first <= last && "vector::erase(first, last) called with invalid range");
			// pointer __p = this->_begin + (first - begin());
			// if (first != last) {
			// 	this->__destruct_at_end(_VSTD::move(__p + (__last - __first), this->__end_, __p));
			// 	this->__invalidate_iterators_past(__p - 1);
			// }
			// return iterator(__p);
		}
*/
		void clear(){
			pointer it = _end;
			while (_begin != it)
				_alloc.destroy(--it);
			_end = _begin;		
		}
		
		//need to wtite ------------
		// void swap(vector& other); // ...

		// bool __invariants() const;
    };

    template <class T, class Allocator> 
	inline bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y) {
		const typename vector<T,Allocator>::size_type sz = x.size();
		return sz == y.size() && ft::equal(x.begin(),x.end(), y.begin());
	}
    template <class T, class Allocator>
	inline bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y) {
		return ft::lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
	}
    template <class T, class Allocator>
	inline bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y) { return !(x == y); }
    template <class T, class Allocator>
	inline bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>&y) { return y < x; }
    template <class T, class Allocator>
	inline bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y) { return !(x < y); }
    template <class T, class Allocator>
	inline bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y) { return !(y < x); }
} // namespace ft

#endif



#ifndef VECTOR_HPP
#define VECTOR_HPP

#include <memory>
#include <cassert>
#include "utility.hpp"
#include "iterator_traits.hpp"

namespace ft
{
//________________________________________________________________________________________________________
//________________________________________________________________________________________________________
	template <class _Iter>
	class base_iter
	// template <class T, class D, class Pt, class Rt>
	// class base_iter : public iterator<std::random_access_iterator_tag, T, D, Pt, Rt>
	{
	public:
		typedef _Iter														iterator_type;
		typedef typename iterator_traits<iterator_type>::iterator_category	iterator_category;
		typedef typename iterator_traits<iterator_type>::value_type			value_type;
		typedef typename iterator_traits<iterator_type>::difference_type	difference_type;
		typedef typename iterator_traits<iterator_type>::pointer			pointer;
		typedef typename iterator_traits<iterator_type>::reference			reference;
		
		// typedef T																					iterator_type;
		// typedef typename iterator<std::random_access_iterator_tag, T, D, Pt, Rt>::iterator_category	iterator_category;
		// typedef typename iterator<std::random_access_iterator_tag, T, D, Pt, Rt>::value_type		value_type;
		// typedef typename iterator<std::random_access_iterator_tag, T, D, Pt, Rt>::difference_type	difference_type;
		// typedef typename iterator<std::random_access_iterator_tag, T, D, Pt, Rt>::pointer			pointer;
		// typedef typename iterator<std::random_access_iterator_tag, T, D, Pt, Rt>::reference			reference;

		// typedef base_iter<T, D, Pt, Rt> my_it;
	private:
		pointer __i;

	public:
		base_iter(){}
		base_iter(pointer __x) : __i(__x) {}
		// template <class _Up> 
		// base_iter(const base_iter<_Up>& __u, typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) 
		//         : __i(__u.base()) {}
		// ~base_iter() {}

		reference operator*() const { return *__i; }
		pointer  operator->() const { return __i; }
		base_iter& operator++(){ ++__i; return *this; }
		base_iter  operator++(int) { base_iter __tmp = *this; ++(*this); return __tmp; }
		base_iter& operator--() { --__i; return *this; }
		base_iter  operator--(int) { base_iter __tmp = *this; --(*this); return __tmp; }
		base_iter  operator+ (difference_type __n) const { base_iter __w(*this); __w += __n; return __w; }
		base_iter& operator+=(difference_type __n) { __i += __n; return *this; }
		base_iter  operator- (difference_type __n) const { return *this + (-__n); }
		base_iter& operator-=(difference_type __n) {*this += -__n; return *this;}
		reference operator[](difference_type __n) const { return __i[__n]; }
		pointer base() {return __i;}

	template <class _Iter1, class _Iter2>
	inline bool operator==(const base_iter<_Iter1>& __x, const base_iter<_Iter2>& __y) { return __x.base() == __y.base(); }
	
	template <class _Iter1, class _Iter2>
	inline bool operator<(const base_iter<_Iter1>& __x, const base_iter<_Iter2>& __y) { return __x.base() < __y.base(); }

	template <class _Iter1, class _Iter2>
	inline bool operator!=(const base_iter<_Iter1>& __x, const base_iter<_Iter2>& __y) { return !(__x == __y); }

	template <class _Iter1, class _Iter2>
	inline bool operator>(const base_iter<_Iter1>& __x, const base_iter<_Iter2>& __y) { return __y < __x; }

	template <class _Iter1, class _Iter2>
	inline bool operator>=(const base_iter<_Iter1>& __x, const base_iter<_Iter2>& __y) { return !(__x < __y); }

	template <class _Iter1, class _Iter2>
	inline bool operator<=(const base_iter<_Iter1>& __x, const base_iter<_Iter2>& __y) { return !(__y < __x); }

	template <class _Iter1>
	inline bool operator!=(const base_iter<_Iter1>& __x, const base_iter<_Iter1>& __y) { return !(__x == __y); }

	template <class _Iter1>
	inline bool operator>(const base_iter<_Iter1>& __x, const base_iter<_Iter1>& __y) { return __y < __x; }

	template <class _Iter1>
	inline bool operator>=(const base_iter<_Iter1>& __x, const base_iter<_Iter1>& __y) { return !(__x < __y); }

	template <class _Iter1>
	inline bool operator<=(const base_iter<_Iter1>& __x, const base_iter<_Iter1>& __y) { return !(__y < __x); }

	template <class _Iter1, class _Iter2>
	inline typename base_iter<_Iter1>::difference_type operator-(const base_iter<_Iter1>& __x, const base_iter<_Iter2>& __y) { return __x.base() - __y.base(); }

	template <class _Iter>
	inline base_iter<_Iter> operator+(typename base_iter<_Iter>::difference_type __n, base_iter<_Iter> __x) { __x += __n; return __x; }
	};

//________________________________________________________________________________________________________
//_____________________________________________VECTOR_____________________________________________________
//________________________________________________________________________________________________________
    template<class T, class Allocator = std::allocator<T> >
    class vector
    {
    public:
		typedef T											value_type;//mlikt
		typedef Allocator									allocator_type;//mlikt
		typedef typename allocator_type::reference			reference;
		typedef typename allocator_type::const_reference	const_reference;
		typedef typename allocator_type::size_type			size_type;
		typedef typename allocator_type::difference_type	difference_type;
		typedef typename allocator_type::pointer			pointer;
		typedef typename allocator_type::const_pointer		const_pointer;
		typedef base_iter<value_type, difference_type, pointer, reference>	iterator;
		typedef base_iter<value_type, difference_type, const_pointer, const_reference>	const_iterator;
		typedef base_iter<value_type *>				   			iterator;
		typedef base_iter<const value_type *>					const_iterator;
		// typedef RandomAccessIterator<value_type>			iterator;
		// typedef RandomAccessIterator<const value_type>		const_iterator;
		typedef ft::reverse_iterator<iterator>				reverse_iterator;
		typedef ft::reverse_iterator<const_iterator>		const_reverse_iterator;

    protected:
		allocator_type		_alloc;
		pointer				_begin;
		pointer				_end;
		pointer				_end_cap;

//construct/copy/destroy:
	public:
		explicit vector(const Allocator& _a = Allocator()) : _begin(nullptr), _end(nullptr), _end_cap(nullptr), _alloc(_a) {}

		explicit vector(size_type n, const T& value = T(), const Allocator& _a= Allocator()) : _alloc(_a){
			if (n > _alloc.max_size())
				throw std::length_error("bad size vector");
			else if (n > 0)
			{
				_begin = _end = _alloc.allocate(n);
				while (n--)
					_alloc.construct(_end++, value);
				_end_cap = _end;
			}
		}

		template <class InputIter>
		vector(InputIter __first, InputIter __last, const Allocator& _a = Allocator(), 
		       typename ft::enable_if<!ft::is_integral<InputIter>::value, void>::type* = 0) //?????
			   : _begin(nullptr), _end(nullptr), _end_cap(nullptr), _alloc(_a)
		{
			size_type n = ft::distance(__first, __last);
			if (n > max_size())
				throw std::length_error("bad size vector");
			_begin = _alloc.allocate(n);
			_end = _end_cap = _begin + n;
			pointer it = _begin;
			while (it != _end)
				_alloc.construct(it++, *__first++);
		}

		vector(const vector<T,Allocator>& x) : _alloc(x.get_allocator()){
			size_type n = x.size();
			pointer it = x._begin;
			if (n > 0)
			{
				_begin = _end = _alloc.allocate(n);
				while (it != x._end)
					_alloc.construct(_end++, *it++);
				_end_cap = _end;
			}
		}

		~vector(){
				if (_begin != nullptr)
				{
						clear();
						_alloc.deallocate(_begin, capacity());
						_begin = _end = _end_cap = nullptr;
				}
		}

		vector<T,Allocator>& operator=(const vector<T,Allocator>& x){
			if (this != &x)
				assign(x._begin, x._end);
			return *this;
		}

		template <class InputIter>
		typename ft::enable_if<!ft::is_integral<InputIter>::value, void>::type 
		assign(InputIter first, InputIter last){
			clear();
			size_type n = static_cast<size_type>(ft::distance(first, last));
			if (capacity() < n)
				reserve(n);
			while (first != last)
				_alloc.construct(_end++, *first++);
		}

		void assign(size_type n, const T& x){
			clear();
			if (capacity() < n)
				reserve(n);
			while (n--)
				_alloc.construct(_end++, x);
		}

		allocator_type get_allocator() const { return _alloc; }
		
//iterators
		iterator begin() { return (iterator(_begin)); }
		const_iterator begin() const { return (const_iterator(_begin)); }
		iterator end() { return (iterator(_end)); }
		const_iterator end() const { return (const_iterator(_end)); }

		reverse_iterator rbegin() { return (reverse_iterator(end())); }
		const_reverse_iterator rbegin() const { return (const_reverse_iterator(end())); }
		reverse_iterator rend() { return (reverse_iterator(begin())); }
		const_reverse_iterator rend() const { return (const_reverse_iterator(begin())); }

//capacity
		size_type size() const { return static_cast<size_type>(_end - _begin); }
		size_type max_size() const {return _alloc.max_size(); }
		size_type capacity() const { return (_end_cap - _begin); }
		bool empty() const { return _begin == _end; }
		void reserve(size_type n)
		{
			if (n > max_size())
				throw std::length_error("bad size vector");
			else if (n > capacity())
			{
				pointer new_begin, new_end;		
				new_begin = new_end = _alloc.allocate(n);
				pointer it = _begin;
				try
				{
					while (it != _end)
						_alloc.construct(new_end++, *it++);
				}
				catch(...)
				{
					_alloc.deallocate(new_begin, n);
					throw ;
				}
				it = _begin;
				while (it != _end)
					_alloc.destroy(it++);
				_alloc.deallocate(_begin, capacity());
				_begin = new_begin;
				_end = new_end;
				_end_cap = _begin + n;
			}
		}

		void resize(size_type n, T c = T()){
			size_type sz = size();
			if (sz < n)
			{
				if (capacity() < n)
					reserve(n);
				pointer new_end = _begin + n;
				while (_end != new_end)
					_alloc.construct(_end++, c);
			}
			else
			{
				pointer new_end = _begin + n;
				while (_end != new_end)
					_alloc.destruct(--_end);
			}
		}

//element access
		reference       operator[](size_type n){
			assert(n < size() && "vector[] index out of bounds");
			return this->_begin[n]; // *(_begin + n); 	
		}
		const_reference operator[](size_type n) const{
			assert(n < size() && "vector[] index out of bounds");
			return this->_begin[n]; // *(_begin + n); 			
		}
		reference       at(size_type n){
			if (n >= size())
				throw std::out_of_range("vector");
			return this->_begin[n]; // *(_begin + n); 	
		}
		const_reference at(size_type n) const{
			if (n >= size())
				throw std::out_of_range("vector");
			return this->_begin[n]; // *(_begin + n); 	
		}
		reference       front() { return *_begin; }
		const_reference front() const { return *_begin; }
		reference       back() { return *(_end - 1); }
		const_reference back() const { return *(_end - 1); }

//Modifiers
		void push_back(const value_type& x){
			size_type csz = capacity();
			if (csz == 0)
				reserve(1);
			else if (_end == _end_cap)
				reserve(2 * csz);
			_alloc.construct(_end++, x);
		}

		void pop_back(){
			assert(!empty() && "vector::pop_back called for empty vector");
			_alloc.destruct(--_end);
		}

		iterator insert(const_iterator position, const value_type& x){
			size_type csz = capacity();
			difference_type diff_pos = position - begin();
			if (_end == _end_cap)
			{
				csz = (csz == 0) ? 1 : 2 * csz;
				if (csz > max_size())
					throw std::length_error("bad size vector");
				pointer new_begin, new_end;		
				new_begin = new_end = _alloc.allocate(csz);
				pointer it = _begin;
				try
				{
					while (it != position)
						_alloc.construct(new_end++, *it++);
					_alloc.construct(new_end++, x);
					while (it != _end)
						_alloc.construct(new_end++, *it++);
				}
				catch(...)
				{
					_alloc.deallocate(new_begin, csz);
					throw ;
				}
				it = _begin;
				while (it != _end)
					_alloc.destroy(it++);
				_alloc.deallocate(_begin, capacity());
				_begin = new_begin;
				_end = new_end;
				_end_cap = _begin + csz;
				position = _begin + diff_pos;
			}
			else
			{
				pointer it = _end - 1;
				_end++;
				while (it != position)
					_alloc.construct(it + 1, *it--);
				_alloc.construct(position, x);
			}
			return iterator(position);
		}

/*
		iterator insert(const_iterator position, size_type n, const value_type& x){
			size_type new_csz = size() + n;
			size_type old_csz = capacity();
			if (old_csz < new_csz)
			{
				old_csz *= 2;
				new_csz = (new_csz > old_csz) ? new_csz : old_csz;
				difference_type diff_pos = position - begin();
				if (new_csz > max_size())
					throw std::length_error("bad size vector");
				pointer new_begin, new_end;		
				new_begin = new_end = _alloc.allocate(new_csz);
				pointer it = _begin;
				try
				{
					while (it != position)
						_alloc.construct(new_end++, *it++);
					it += n;
					while (it != _end)
						_alloc.construct(new_end++, *it++);
				}
				catch(...)
				{
					_base::_alloc.deallocate(new_begin, n);
					throw ;
				}
				it = _begin;
				while (it != _end)
					_alloc.destroy(it++);
				_alloc.deallocate(_begin, capacity());
				_begin = new_begin;
				_end = new_end;
				_end_cap = _begin + new_csz;
				position = _begin + diff_pos;
			}
			else
			{
				pointer it = _end - 1;
				_end += n;
				while (it != position)
					_alloc.construct(it + n, *it--);
			}
			for (size_type i = 0; i < n; i++)
				_alloc.construct(position + i, x);
			return iterator(position);
		}

		template <class InputIter>
		typename ft::enable_if<!ft::is_integral<InputIter>::value, void>::type
		insert(const_iterator position, InputIter first, InputIter last){}
		iterator erase(iterator position){}
		iterator erase(iterator first, iterator last){}
*/
		void clear(){
			pointer it = _end;
			while (_begin != it)
				_alloc.destroy(--it);
			_end = _begin;		
		}
		
		//need to wtite ------------
		// void swap(vector& other); // ...

		// bool __invariants() const;
    };

    template <class T, class Allocator> 
	inline bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y) {
		const typename vector<T,Allocator>::size_type sz = x.size();
		return sz == y.size() && ft::equal(x.begin(),x.end(), y.begin());
	}
    template <class T, class Allocator>
	inline bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y) {
		return ft::lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
	}
    template <class T, class Allocator>
	inline bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y) { return !(x == y); }
    template <class T, class Allocator>
	inline bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>&y) { return y < x; }
    template <class T, class Allocator>
	inline bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y) { return !(x < y); }
    template <class T, class Allocator>
	inline bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y) { return !(y < x); }
} // namespace ft

#endif


	// template< typename L>class RandomAccessIterator
	// {
	// public:
	// 	typedef	typename iterator_traits<L*>::value_type 	value_type;
	// 	typedef	typename iterator_traits<L*>::pointer	pointer;
	// 	typedef	typename iterator_traits<L*>::reference	reference;
	// 	typedef	typename iterator_traits<L*>::difference_type	difference_type;
	// 	typedef pointer iterator_type;
	// 	//this is for std::functions
	// 	typedef	std::random_access_iterator_tag iterator_category;

	// 	//maybe protected???
	// private:
	// 	pointer _ptr;

	// public:

	// 	// CONSTRUCTORS
	// 	RandomAccessIterator() : _ptr() {}

	// 	RandomAccessIterator(pointer a) : _ptr(a) {}

	// 	virtual ~RandomAccessIterator() {}

	// 	// RandomAccessIterator(const RandomAccessIterator<typename std::remove_const<value_type>::type > & src) : _ptr(&(*src)) {}

	// 	RandomAccessIterator<value_type> & operator=(RandomAccessIterator<typename remove_const<value_type>::type > const & src) {
	// 		_ptr = &(*src);
	// 		return *this;
	// 	}

	// 	//OPERATORS
	// 	RandomAccessIterator & operator++() {
	// 		++_ptr;
	// 		return *this;
	// 	}

	// 	RandomAccessIterator operator++(int) {
	// 		RandomAccessIterator tmp(*this);
	// 		++_ptr;
	// 		return tmp;
	// 	}

	// 	RandomAccessIterator & operator--() {
	// 		--_ptr;
	// 		return *this;
	// 	}

	// 	RandomAccessIterator  operator--(int) {
	// 		RandomAccessIterator tmp = *this;
	// 		--_ptr;
	// 		return tmp;
	// 	}
	// 	RandomAccessIterator operator+(const difference_type & a) const {
	// 		return _ptr + a;
	// 	}

	// 	RandomAccessIterator operator-(const difference_type & a) const {
	// 		return _ptr - a;
	// 	}

	// 	RandomAccessIterator & operator+=(const difference_type & a) {
	// 		_ptr += a;
	// 		return (*this);
	// 	}

	// 	RandomAccessIterator & operator-=(const difference_type & a) {
	// 		_ptr -= a;
	// 		return (*this);
	// 	}

	// 	pointer operator->() const {
	// 		return _ptr;
	// 	}

	// 	reference operator*() const {
	// 		return *_ptr;
	// 	}

	// 	reference operator[](difference_type n) const {
	// 		return *(_ptr + n);
	// 	}
	// };

	// public:
	// template<typename A, typename B>
	// 	friend bool operator==(const vector::template RandomAccessIterator<A> & lhs, const vector::template RandomAccessIterator<B> & rhs){
	// 		return &(*lhs) == &(*rhs);


	// 	}

	// 	template<typename A, typename B>
	// 	friend bool operator!=(const vector::template RandomAccessIterator<A> & lhs, const vector::template RandomAccessIterator<B> & rhs) {
	// 		return &(*lhs) != &(*rhs);
	// 	}

	// 	template<typename A, typename B>
	// 	friend bool operator>(const vector::template RandomAccessIterator<A> & lhs, const vector::template RandomAccessIterator<B> & rhs) {
	// 		return &(*lhs) > &(*rhs);
	// 	}

	// 	template<typename A, typename B>
	// 	friend bool operator<(const vector::template RandomAccessIterator<A> & lhs, const vector::template RandomAccessIterator<B> & rhs) {
	// 		return &(*lhs) < &(*rhs);
	// 	}

	// 	template<typename A, typename B>
	// 	friend bool operator<=(const vector::template RandomAccessIterator<A> & lhs, const vector::template RandomAccessIterator<B> & rhs) {
	// 		return &(*lhs) <= &(*rhs);
	// 	}


	// 	template<typename A, typename B>
	// 	friend bool operator>=(const vector::template RandomAccessIterator<A> & lhs, const vector::template RandomAccessIterator<B> & rhs) {
	// 		return &(*lhs) >= &(*rhs);
	// 	}

	// 	template<typename A, typename B>
	// 	friend typename vector::template RandomAccessIterator<A>::difference_type operator-(const vector::template RandomAccessIterator<A> & lhs, const vector::template RandomAccessIterator<B> & rhs){
	// 		return &(*lhs) - &(*rhs);
	// 	}

	// 	template<typename A, typename B>
	// 	friend typename vector::template RandomAccessIterator<A>::difference_type operator+(const vector::template RandomAccessIterator<A> & lhs, const vector::template RandomAccessIterator<B> & rhs){
	// 		return &(*lhs) + &(*rhs);
	// 	}

	// 	template<typename L>
	// 	friend vector::template RandomAccessIterator<L> operator +(const typename vector::template RandomAccessIterator<L>::difference_type & a, const vector::template RandomAccessIterator<L> & iter){
	// 		return	(iter + a);
	// 	}

	// 	template<typename L>
	// 	friend vector::template RandomAccessIterator<L> operator -(const typename vector::template RandomAccessIterator<L>::difference_type & a, const vector::template RandomAccessIterator<L> & iter){
	// 		return	(iter - a);
	// 	}


	#ifndef RB_TREE_HPP
#define RB_TREE_HPP

#include "utility.hpp"
#include "iterator_traits.hpp"
#include "tree_iterator.hpp"
#include <memory>

namespace ft
{
	template <class T, class Compare = std::less<T>, class Allocator = std::allocator<T> >
	class rb_tree
	{
	public:
		// types:
		typedef T											value_type;
		typedef Compare										value_compare;
		typedef Allocator									allocator_type;
		typedef value_type&									reference;
		typedef const value_type&							const_reference;
		typedef tree_iter<value_type>    		            iterator;
		typedef tree_iter<const value_type>                 const_iterator;
		typedef ft::reverse_iterator<iterator>				reverse_iterator;
		typedef ft::reverse_iterator<const_iterator>		const_reverse_iterator;
		typedef typename allocator_type::template
		rebind<Node<value_type> >::other					node_allocator;
		typedef	typename node_allocator::pointer			pointer;
		typedef typename node_allocator::const_pointer		const_pointer;
		typedef typename node_allocator::size_type			size_type;
		typedef typename node_allocator::difference_type	difference_type;


	private:
		allocator_type													_alloc;
		node_allocator													_node_alloc;
		value_compare 													_compare;
		node_pointer													_begin_node;
		node_pointer													_end_node;
		node_pointer													_root;
		size_type														_size;

	public:

//construct/copy/destroy:
	rb_tree() : {} // ????
    explicit rb_tree(const value_compare& __comp) : _size(0), _compare(__comp) {
		_begin_node = _end_node;
	}
    explicit rb_tree(const allocator_type& __a);
    rb_tree(const value_compare& __comp, const allocator_type& __a);
    rb_tree(const rb_tree& __t);
    rb_tree& operator=(const rb_tree& __t);

// ___________________________________

    __iter_pointer                                     __begin_node_;
    __compressed_pair<__end_node_t, __node_allocator>  __pair1_;
    __compressed_pair<size_type, value_compare>        __pair3_;

public:
    _LIBCPP_INLINE_VISIBILITY
    __iter_pointer __end_node() _NOEXCEPT
    {
        return static_cast<__iter_pointer>(
                pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first())
        );
    }
    _LIBCPP_INLINE_VISIBILITY
    __iter_pointer __end_node() const _NOEXCEPT
    {
        return static_cast<__iter_pointer>(
            pointer_traits<__end_node_ptr>::pointer_to(
                const_cast<__end_node_t&>(__pair1_.first())
            )
        );
    }
    _LIBCPP_INLINE_VISIBILITY
          __node_allocator& __node_alloc() _NOEXCEPT {return __pair1_.second();}
private:
    _LIBCPP_INLINE_VISIBILITY
    const __node_allocator& __node_alloc() const _NOEXCEPT
        {return __pair1_.second();}
    _LIBCPP_INLINE_VISIBILITY
          __iter_pointer& __begin_node() _NOEXCEPT {return __begin_node_;}
    _LIBCPP_INLINE_VISIBILITY
    const __iter_pointer& __begin_node() const _NOEXCEPT {return __begin_node_;}




template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp)
        _NOEXCEPT_(
            is_nothrow_default_constructible<__node_allocator>::value &&
            is_nothrow_copy_constructible<value_compare>::value)
    : __pair3_(0, __comp)
{
    __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)
    : __begin_node_(__iter_pointer()),
      __pair1_(__second_tag(), __node_allocator(__a)),
      __pair3_(0)
{
    __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp,
                                           const allocator_type& __a)
    : __begin_node_(__iter_pointer()),
      __pair1_(__second_tag(), __node_allocator(__a)),
      __pair3_(0, __comp)
{
    __begin_node() = __end_node();
}



__tree<_Tp, _Compare, _Allocator>::~__tree()
{
    static_assert((is_copy_constructible<value_compare>::value),
                 "Comparator must be copy-constructible.");
  destroy(__root());
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) _NOEXCEPT
{
    if (__nd != nullptr)
    {
        destroy(static_cast<__node_pointer>(__nd->__left_));
        destroy(static_cast<__node_pointer>(__nd->__right_));
        __node_allocator& __na = __node_alloc();
        __node_traits::destroy(__na, _NodeTypes::__get_ptr(__nd->__value_));
        __node_traits::deallocate(__na, __nd, 1);
    }
}

// ___________________________________

		rb_tree& operator=(const rb_tree& __m)
			{
				if (this != &__m) {
					__tree_.clear();
					__tree_.value_comp() = __m.__tree_.value_comp();
					__tree_.__copy_assign_alloc(__m.__tree_);
					insert(__m.begin(), __m.end());
				}
				return *this;
			}

		allocator_type get_allocator() const {return allocator_type(__tree_.__alloc());}

//iterators
		iterator begin() {return __tree_.begin();}
		const_iterator begin() const {return __tree_.begin();}
		iterator end() {return __tree_.end();}
		const_iterator end() const {return __tree_.end();}

		reverse_iterator rbegin() {return reverse_iterator(end());}
		const_reverse_iterator rbegin() const {return const_reverse_iterator(end());}
		reverse_iterator rend() {return reverse_iterator(begin());}
		const_reverse_iterator rend() const {return const_reverse_iterator(begin());}

//capacity
		bool      empty() const {return __tree_.size() == 0;}
		size_type size() const {return __tree_.size();}
		size_type max_size() const {return __tree_.max_size();}

//element access
		mapped_type& operator[](const key_type& __k);

		mapped_type& at(const key_type& __k);
		const mapped_type& at(const key_type& __k) const;

//modifiers


		key_compare    key_comp()      const {return __tree_.value_comp().key_comp();}

		value_compare  value_comp()    const {return value_compare(__tree_.value_comp().key_comp());}

		pair<iterator, bool> insert(const value_type& __v)
			{return __tree_.__insert_unique(__v);}

		iterator insert(const_iterator __p, const value_type& __v)
			{return __tree_.__insert_unique(__p.__i_, __v);}

		template <class InputIter>
		void insert(InputIter __f, InputIter __l)
		{
			for (const_iterator __e = cend(); __f != __l; ++__f)
				insert(__e.__i_, *__f);
		}

		iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}

		iterator erase(iterator __p)       {return __tree_.erase(__p.__i_);}

		size_type erase(const key_type& __k)
			{return __tree_.__erase_unique(__k);}

		iterator  erase(const_iterator __f, const_iterator __l)
			{return __tree_.erase(__f.__i_, __l.__i_);}

		void clear() {__tree_.clear();}

		void swap(rb_tree& __m) {__tree_.swap(__m.__tree_);}

//lookup
		iterator find(const key_type& __k)		     {return __tree_.find(__k);}

		const_iterator find(const key_type& __k) const {return __tree_.find(__k);}

		size_type count(const key_type& __k) const
			{return __tree_.__count_unique(__k);}

		iterator lower_bound(const key_type& __k)
			{return __tree_.lower_bound(__k);}

		const_iterator lower_bound(const key_type& __k) const
			{return __tree_.lower_bound(__k);}

		iterator upper_bound(const key_type& __k)
			{return __tree_.upper_bound(__k);}

		const_iterator upper_bound(const key_type& __k) const
			{return __tree_.upper_bound(__k);}

		pair<iterator,iterator> equal_range(const key_type& __k)
			{return __tree_.__equal_range_unique(__k);}

		pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
			{return __tree_.__equal_range_unique(__k);}

	};
   
} // namespace ft

#endif